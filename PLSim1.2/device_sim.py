from graph_data import make_graph,show_graph
'''
Simulates the device using a file that denotes whether a device is on or off at any given time with
with intervals designated in a csv file that follows the format

    device,state,on/off
    
    ie
    
    tv,on,111111010101111110000011111
'''
#from test.test_wsgiref import IntegrationTests #This line is potentially extraneous
import csv
import numpy as np


def write_to_ifile(file_name: str, integration_period:int, input_generators: list):
    '''writes the strings generated by the string generators onto the input csv'''
    with open(file_name, 'w') as outfile:
        to_write = 'sample_rate:{}\n'.format(integration_period)
        for input_generator in input_generators:
            to_write += input_generator.generate_str()
        outfile.write(to_write)
        
def write_to_peramfile(file_name: str, integration_period: int, device_map: dict):
    '''writes the strings generated by the string generators onto the input csv'''
    with open(file_name, 'w') as outfile:
        to_write = 'sample_rate:{}\n'.format(integration_period)
        to_write += str(device_map)
        outfile.write(to_write)
        
def make_integral_array(power_array: list, integration_period: int):
    to_return = [0]
    for i in range(len(power_array)-1):
        to_return.append(energy_used(power_array[i:i+2], integration_period) + to_return[-1])
    return to_return

def write_to_csv(file_name, power_array: list, integral_array: list, integration_time,power_factor_array,thdI_array):
    time_array = list(range(0, len(power_array)*integration_time, integration_time))
    with open(file_name, 'w+', newline='') as csv_file:
        csv_writer = csv.writer(csv_file, delimiter=',',
                            quotechar='|', quoting=csv.QUOTE_MINIMAL)
        csv_file.write('time,')
        csv_writer.writerow(time_array)
        csv_file.write('power,')
        csv_writer.writerow(power_array)
        csv_file.write('energy,')
        csv_writer.writerow(integral_array)
        csv_file.write('power_factor,')
        csv_writer.writerow(power_factor_array)
        csv_file.write('thdI,')
        csv_writer.writerow(thdI_array)
    
        csv_file.close()
        
def analyze_data(file_name: str, integration_period: int, device_map: dict):
    cate_map = parse_inputfile(file_name, device_map)
    power_array = cate_map['power']
    power_factor_array = cate_map['power_factor']
    thdI_array = cate_map['thdI']

    integral_array = make_integral_array(power_array, integration_period)
    print('integral',integral_array)
    
    print('\nEnergy Used: ', integral_array[-1], 'Watt-hours')

    # TODO: DRAW MORE GRAPHS HERE, just input arrays and change '211' into 'x1y', x:total number of graphs, y:position of the graph
    make_graph(power_array, integration_period,'', 'Power (W)', 'Power Consumed',sub=321)
    make_graph(integral_array, integration_period, 'Time (hr)', 'Energy (W*hr)', 'Energy Used',sub=322)
    make_graph(power_factor_array, integration_period, '', 'Power Factor', 'Power Factor Graph', sub=325)
    make_graph(thdI_array, integration_period, '', 'thdI', 'thdI Graph', sub=326)

    write_to_csv('outputs/graph_file.csv', power_array, integral_array, integration_period,power_factor_array,thdI_array)
    show_graph()
    
def analyze_data_nograph(file_name: str, integration_period: int, device_map: dict):
    power_map = parse_inputfile(file_name, device_map)
    power_matrix = list(power_map.values())       
    power_array = flatten_cols(power_matrix)
    integral_array = make_integral_array(power_array, integration_period)
    
    return (power_map, power_matrix, power_array, integral_array)
    
def energy_used(power_array, int_period: int):
    '''trapezoidal riemman sum estimate of the amount of power used'''
    return (sum(power_array[1:])/3600*int_period + sum(power_array[:len(power_array)-1])/3600*int_period)/2

def make_int_array(size, start_value=0):
    '''returns an int list of length size with values start_value, default being 0'''
    to_return = []
    for i in range(size):
        to_return.append(0)
    
    return to_return

def flatten_cols(matrix: [list])->list:
    '''flatten a matrix by m by n into a array of size m by adding columns together
    ie
        | a_00 a_10 ... a_m0 |
        | a_01 ............. |
        |  ................. |  = [a_00 + a_01 + .. + a_0n, a_10 + a_11 + ... + a_1n, a_m0 + a_m1 + ... + a_mn]
        | a_0n ........ a_mn |
    '''
    
    to_return = []
    size = len(matrix[0])
    
    for j in range(size):
        to_append = 0
        for i in range(len(matrix)):
            assert(len(matrix[i]) == size)
            to_append += matrix[i][j]
        to_return.append(to_append)
        
    return to_return

def read_from_peramfile(file_name: str):   #not fully implemented yet
    with open(file_name, 'r') as infile:
        read_integration_period_temp = infile.readline().strip() #Read first line only for integration period
        read_integration_period = read_integration_period_temp[12:]  #read only the number in the first line
        read_device_map = {}
        cache = infile.readlines()[0:]  #dumb read-in of string in file - start after header
               # loop through lines
        for line in cache:
            # skip lines starting with "--".
            if not line.startswith("--"):
                # replace random amount of spaces (\s) with tab (\t),
                # strip the trailing return (\n), split into list using
                # "\t" as the split pattern
                line = line.split()
                # use first item in list for the key, join remaining list items
                # with ", " for the value.
                read_device_map[(line[0])] = ",  ".join(line[1:])  #example parser cose, but this does not format correctly

           
    return read_integration_period, read_device_map

    
def parse_inputstring(device, state, device_map, i_string:str, to_write:list)->list:
    '''an input string is a string of 1s and 0s that represent whether or not the device,state is on at
    a given time interval
    '''
    assert(len(to_write) == len(i_string))
    for i in range(len(i_string)):
        inst_st = int(i_string[i])
        if inst_st == 1:
            assert(to_write[i] == 0) # assert that to_write is already empty
        to_write[i] += int(inst_st)* device_map[device][state]
    
    return to_write

def parse_inputfile(file, device_map)-> dict:
    '''parses the device input file which is a csv file with format
    device, state, on/off string
    
    on/off string denotes with a 1 or a 0 whether or not a device is on during that time
    '''
    to_return = {}
    
    with open(file, 'r') as i_file:
        for line in i_file:
            if line[:11] == 'sample_rate':
                pass #lol beautiful code right here ima keep this for kicks
            else:
                info = line.rstrip().split(',')
                device, state, i_string = info[0], info[1], info[2]

                # add up all values
                state_np = np.array(list(i_string), dtype=float)
                if not to_return:
                    for i in device_map:
                        for j in device_map[i]:
                            for cate in list(device_map[i][j].keys()):
                                to_return[cate] = np.zeros_like(state_np)
                            break
                        break
                for cate in device_map[device][state]:
                    to_return[cate] += state_np*device_map[device][state][cate]

    return to_return

def mapval_to_matrix(map: dict)->list:

    # maybe do some error checking here?
    
    return list(map.values())
            
    
    
if __name__ == '__main__':
    # rudimentary testing
    
    # test flatten_cols
    assert(flatten_cols([[1,3,4],
                         [2,3,4],
                         [5,6,7]]) == [8,12,15])
    
    # test parse_input_srting
    power_array = [0,0,0,0,0,0,0,0,0,0]
    dev_map = {'television': {'on':100, 'off':0, 'standby':25}, 'xbox': {'on':70, 'off':0, 'standby':20}}
    input_str_tv = '1110000111'
    input_str_stndby = '0001111000'
    
    parse_inputstring('television', 'on', dev_map, input_str_tv, power_array)
    parse_inputstring('television', 'standby', dev_map, input_str_stndby, power_array)
    assert(power_array == [100, 100, 100, 25, 25, 25, 25, 100, 100, 100])
    print(energy_used(power_array, 1800))
    print(make_integral_array(power_array, 1800))
    
    # test parse_inputfile
    
    #d = parse_inputfile('test_input.csv', dev_map)
    #print(d)
    
    